// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                 String   @id @default(cuid())
  full_name          String
  email              String   @unique
  password           String
  points             Int      @default(0)
  barcode            String   @unique
  stripe_customer_id String?  // ID client Stripe pour les paiements récurrents
  role               UserRole @default(CUSTOMER) // Nouveau: rôle de l'utilisateur
  created_at         String   @default(dbgenerated("now()::text"))

  // Relations
  orders       Order[]
  restocks     Restock[] // Nouveaux: restocks effectués par cet utilisateur (si ADMIN/OPERATOR)

  @@map("users")
}

model Product {
  id                String  @id @default(cuid())
  name              String
  description       String
  // Prix de vente
  price             Decimal @db.Decimal(10, 2)
  // Prix d'achat (pour calcul de marge)
  purchase_price    Decimal @db.Decimal(10, 2)
  // Catégorie du produit
  category          String
  sku               String? // Nouveau: identifiant unique produit pour import CSV
  ingredients       String
  ingredients_list  String[]  // Liste structurée des ingrédients
  allergens         String
  allergens_list    String[] @default([]) // Liste structurée des allergènes (optionnelle côté métier)
  nutritional_value String
  nutritional       Json?     // Valeurs nutritionnelles structurées {calories, protein, carbs, fat}
  image_url         String
  is_active         Boolean @default(true)
  created_at        String  @default(dbgenerated("now()::text"))

  // Relations
  stocks      Stock[]
  order_items OrderItem[]

  @@unique([sku]) // SKU doit être unique si fourni
  @@index([category])
  @@map("products")
}

model Machine {
  id           String        @id @default(cuid())
  location     String
  label        String
  contact      String?
  status       MachineStatus @default(OFFLINE)
  last_sync_at String?       // Nouveau: dernière synchronisation pour affichage online/offline
  created_at   String        @default(dbgenerated("now()::text"))
  last_update  String        @default(dbgenerated("now()::text"))

  // Relations
  stocks   Stock[]
  orders   Order[]
  pickups  Pickup[]
  restocks Restock[] // Nouveau: historique des restocks de cette machine
  alerts   Alert[]   // Nouveau: alertes générées par cette machine

  @@map("machines")
}

model Stock {
  id            String @id @default(cuid())
  machine_id    String
  product_id    String
  quantity      Int    @default(0)
  slot_number   Int
  max_capacity  Int    @default(10) // Nouveau: capacité maximale du slot
  low_threshold Int    @default(2)  // Nouveau: seuil d'alerte stock faible
  created_at    String @default(dbgenerated("now()::text"))
  updated_at    String @default(dbgenerated("now()::text"))

  // Relations
  machine           Machine            @relation(fields: [machine_id], references: [id], onDelete: Cascade)
  product           Product            @relation(fields: [product_id], references: [id], onDelete: Cascade)
  stockReservations StockReservation[]
  restockItems      RestockItem[]      // Nouveau: items de restock pour ce slot
  alerts            Alert[]            // Nouveau: alertes liées à ce slot

  @@unique([machine_id, slot_number]) // Contrainte ajoutée pour éviter les conflits de slots
  @@index([machine_id, product_id])
  @@map("stocks")
}

// Table pour gérer les réservations de stock
model StockReservation {
  id          String @id @default(cuid())
  stock_id    String
  quantity    Int
  reserved_at String @default(dbgenerated("now()::text"))
  expires_at  String
  status      String @default("ACTIVE") // ACTIVE, EXPIRED, RELEASED
  order_id    String? // Optionnel, lié à une commande spécifique

  // Relations
  stock Stock @relation(fields: [stock_id], references: [id], onDelete: Cascade)

  @@index([stock_id, status])
  @@index([expires_at])
  @@map("stock_reservations")
}

model Order {
  id                        String      @id @default(cuid())
  user_id                   String
  machine_id                String
  status                    String      @default("PENDING") // Changé de OrderStatus à String pour compatibilité
  created_at                String      @default(dbgenerated("now()::text"))
  expires_at                String
  qr_code_token            String      @unique
  
  // Nouveaux champs pour les paiements
  amount_total_cents        Int         @default(0) // Montant total en centimes
  currency                  String      @default("EUR") @db.VarChar(3)
  stripe_payment_intent_id  String?     @unique // ID de l'intention de paiement Stripe
  paid_at                   String?     // Timestamp du paiement réussi
  receipt_url               String?     // URL du reçu Stripe
  
  // Fidélité (source de vérité au niveau de la commande)
  points_spent              Int         @default(0)
  points_earned             Int         @default(0)
  loyalty_applied           Boolean     @default(false)

  // Relations
  user    User        @relation(fields: [user_id], references: [id], onDelete: Cascade)
  machine Machine     @relation(fields: [machine_id], references: [id], onDelete: Cascade)
  items   OrderItem[]
  pickups Pickup[]
  payment Payment?    // Relation 1:1 avec Payment
  actions OrderAction[] // Actions effectuées sur cette commande

  @@index([user_id, created_at(sort: Desc)])
  @@index([stripe_payment_intent_id])
  @@map("orders")
}

model OrderItem {
  id                String @id @default(cuid())
  order_id          String
  product_id        String
  quantity          Int
  slot_number       Int
  
  // Snapshots immuables pour la stabilité des prix
  unit_price_cents  Int    @default(0) // Prix unitaire au moment de la commande (en centimes)
  label             String? // Nom du produit au moment de la commande
  subtotal_cents    Int    @default(0) // Sous-total en centimes (unit_price_cents * quantity)

  // Relations
  order   Order   @relation(fields: [order_id], references: [id], onDelete: Cascade)
  product Product @relation(fields: [product_id], references: [id], onDelete: Cascade)

  @@map("order_items")
}

model Pickup {
  id           String       @id @default(cuid())
  order_id     String
  machine_id   String
  picked_up_at String       @default(dbgenerated("now()::text"))
  status       PickupStatus @default(PENDING)

  // Relations
  order   Order   @relation(fields: [order_id], references: [id], onDelete: Cascade)
  machine Machine @relation(fields: [machine_id], references: [id], onDelete: Cascade)

  @@map("pickups")
}

// Loyalty logs supprimés: l'historique est dérivé de `orders` (points_spent/points_earned)

// Nouvelles tables pour le système de paiement robuste

model Payment {
  id                        String @id @default(cuid())
  order_id                  String @unique // Relation 1:1 avec Order
  stripe_payment_intent_id  String @unique // ID unique de l'intention de paiement Stripe
  amount_cents              Int    // Montant en centimes
  currency                  String @db.VarChar(3) // Devise (EUR, USD, etc.)
  status                    String // Miroir Stripe: requires_payment_method|processing|succeeded|canceled|requires_action|...
  last_error_code           String? // Code d'erreur Stripe le plus récent
  last_error_message        String? // Message d'erreur Stripe le plus récent
  created_at                String @default(dbgenerated("now()::text"))
  updated_at                String @default(dbgenerated("now()::text"))

  // Relations
  order         Order          @relation(fields: [order_id], references: [id], onDelete: Cascade)
  paymentEvents PaymentEvent[]
  refunds       Refund[]

  @@index([stripe_payment_intent_id])
  @@map("payments")
}

model PaymentEvent {
  id                String @id @default(cuid())
  payment_id        String
  order_id          String // Ajout du champ order_id manquant
  stripe_event_id   String @unique // ID unique de l'événement Stripe
  type              String // Type d'événement Stripe
  payload           Json   // Payload complet de l'événement Stripe
  created_at        String @default(dbgenerated("now()::text"))

  // Relations
  payment Payment @relation(fields: [payment_id], references: [id], onDelete: Cascade)

  @@index([stripe_event_id])
  @@map("payment_events")
}

model Refund {
  id                String @id @default(cuid())
  payment_id        String
  stripe_refund_id  String @unique // ID unique du remboursement Stripe
  amount_cents      Int    // Montant remboursé en centimes
  status            String // pending|succeeded|failed|canceled
  reason            String? // Raison du remboursement
  created_at        String @default(dbgenerated("now()::text"))

  // Relations
  payment Payment @relation(fields: [payment_id], references: [id], onDelete: Cascade)

  @@index([payment_id, created_at(sort: Desc)])
  @@map("refunds")
}

// Table pour l'idempotence des actions sur les commandes
model OrderAction {
  id         String @id @default(cuid())
  order_id   String
  action     String // Nom de l'action (ex: "credit_loyalty", "decrement_stock")
  created_at String @default(dbgenerated("now()::text"))

  // Relations
  order Order @relation(fields: [order_id], references: [id], onDelete: Cascade)

  // Contrainte unique pour éviter les actions dupliquées
  @@unique([order_id, action], name: "order_id_action")
  @@map("order_actions")
}

// Nouveaux modèles pour le back-office

model Restock {
  id          String @id @default(cuid())
  machine_id  String
  user_id     String // Utilisateur qui a effectué le restock (ADMIN/OPERATOR)
  created_at  String @default(dbgenerated("now()::text"))
  notes       String? // Notes optionnelles sur le restock

  // Relations
  machine Machine       @relation(fields: [machine_id], references: [id], onDelete: Cascade)
  user    User          @relation(fields: [user_id], references: [id], onDelete: SetNull)
  items   RestockItem[] // Détails des produits/slots restockés

  @@index([machine_id, created_at(sort: Desc)])
  @@map("restocks")
}

model RestockItem {
  id               String @id @default(cuid())
  restock_id       String
  stock_id         String // Référence au slot (Stock)
  quantity_before  Int    // Quantité avant restock
  quantity_after   Int    // Quantité après restock
  quantity_added   Int    // Quantité ajoutée (quantity_after - quantity_before)

  // Relations
  restock Restock @relation(fields: [restock_id], references: [id], onDelete: Cascade)
  stock   Stock   @relation(fields: [stock_id], references: [id], onDelete: Cascade)

  @@index([restock_id])
  @@map("restock_items")
}

model Alert {
  id         String      @id @default(cuid())
  machine_id String
  stock_id   String?     // Nouveau: FK optionnel vers Stock pour alertes de stock
  type       AlertType   @default(LOW_STOCK)
  message    String?
  level      AlertLevel  @default(WARNING)
  status     AlertStatus @default(OPEN)
  is_active  Boolean     @default(true) // Pour déduplication: une seule alerte active par machine/type
  created_at String      @default(dbgenerated("now()::text"))
  resolved_at String?    // Quand l'alerte a été résolue
  
  // Métadonnées spécifiques selon le type d'alerte
  metadata   Json?       // Par exemple: {"slot_number": 1, "current_quantity": 1, "threshold": 2}

  // Relations
  machine Machine @relation(fields: [machine_id], references: [id], onDelete: Cascade)
  stock   Stock?  @relation(fields: [stock_id], references: [id], onDelete: SetNull)

  @@index([machine_id, status, created_at(sort: Desc)])
  @@index([type, status])
  @@index([stock_id, status])
  @@index([machine_id, type, is_active]) // Pour déduplication
  @@map("alerts")
}

// Enums
enum UserRole {
  CUSTOMER  // Client normal
  OPERATOR  // Opérateur - peut gérer stocks et machines
  ADMIN     // Administrateur - accès complet
}

enum AlertType {
  LOW_STOCK    // Stock faible (≥50% des slots sous le seuil critique)
  CRITICAL     // Stock critique (≥1 slot vide)
  INCOMPLETE   // Machine incomplète (slots non configurés)
  MACHINE_OFFLINE // Machine hors ligne
  MAINTENANCE_REQUIRED // Maintenance requise
}

enum AlertLevel {
  INFO     // Information
  WARNING  // Avertissement
  ERROR    // Erreur
  CRITICAL // Critique
}

enum AlertStatus {
  OPEN     // Ouverte
  RESOLVED // Résolue
  IGNORED  // Ignorée
}

enum MachineStatus {
  ONLINE
  OFFLINE
  MAINTENANCE
  OUT_OF_SERVICE
}

enum OrderStatus {
  PENDING
  ACTIVE
  EXPIRED
  USED
  CANCELLED
}

enum PickupStatus {
  PENDING
  COMPLETED
  FAILED
}

